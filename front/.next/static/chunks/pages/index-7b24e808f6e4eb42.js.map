{"version":3,"file":"static/chunks/pages/index-7b24e808f6e4eb42.js","mappings":"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","sources":["webpack://_N_E/./components/PostForm.js","webpack://_N_E/./pages/index.js","webpack://_N_E/","webpack://_N_E/./node_modules/react-intersection-observer/react-intersection-observer.modern.mjs","webpack://_N_E/<anon>"],"sourcesContent":["import React, { useCallback, useRef, useEffect } from \"react\";\r\nimport { Form, Button, Input } from \"antd\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport useInput from \"../hooks/useInput\";\r\n\r\nimport {\r\n  UPLOAD_IMAGES_REQUEST,\r\n  REMOVE_IMAGE,\r\n  ADD_POST_REQUEST,\r\n} from \"../reducers/post\";\r\nimport { backURL } from \"../config/config\";\r\n\r\nconst PostForm = () => {\r\n  const { imagePaths, addPostDone } = useSelector((state) => state.post);\r\n  const dispatch = useDispatch();\r\n  // ref는 실제 DOM에 접근하기 위해 사용\r\n  const imageInput = useRef();\r\n  const [text, onChangeText, setText] = useInput(\"\");\r\n\r\n  // 서버쪽에서 에러 발생 했는데 setText(\"\") 되면 안되니까\r\n  // post가 정상적으로 업로드 되면 setText(\"\")가 실행되도록\r\n  useEffect(() => {\r\n    if (addPostDone) {\r\n      setText(\"\");\r\n    }\r\n  }, [addPostDone]);\r\n\r\n  const onSubmit = useCallback(() => {\r\n    if (!text || !text.trim()) {\r\n      return alert(\"게시글을 작성하세요.\");\r\n    }\r\n    const formData = new FormData();\r\n    imagePaths.forEach((path) => {\r\n      formData.append(\"image\", path);\r\n    });\r\n    formData.append(\"content\", text);\r\n    dispatch({\r\n      type: ADD_POST_REQUEST,\r\n      data: formData,\r\n    });\r\n    // 여기서 setText(\"\") 하면 안됨\r\n    // setText(\"\");\r\n  }, [text, imagePaths]);\r\n\r\n  const onClickImageUpload = useCallback(() => {\r\n    // 이미지 업로드 버튼 클릭 시 input 태그 클릭되도록\r\n    imageInput.current.click();\r\n  }, [imageInput.current]);\r\n\r\n  const onChangeImages = useCallback((e) => {\r\n    console.log(\"images: \" + e.target.files);\r\n    // FormData는 HTML5에서 추가된 Web API 중 하나로, HTML <form> 태그와 같이 폼 데이터를 쉽게 생성하고 제출할 수 있도록 해줍니다.\r\n    // FormData 객체를 생성할 때, new FormData()와 같이 생성자를 호출합니다. 이후에는 append() 메소드를 사용하여 폼 데이터를 추가할 수 있습니다.\r\n    const imageFormData = new FormData();\r\n    // e.target.files은 File객체다. 그래서 [].forEach.call(e.target.files, (file)=>{}) 이렇게 사용하면 File객체가 빈배열에 들어가서 반복문이 돌아간다.\r\n    // file에서는 각 객체값이 전달된다.\r\n    [].forEach.call(e.target.files, (file) => {\r\n      // append() 메소드는 두 개의 인자를 받으며, 첫 번째 인자는 데이터의 이름(name), 두 번째 인자는 데이터의 값(value)입니다.\r\n      imageFormData.append(\"image\", file);\r\n    });\r\n    dispatch({\r\n      type: UPLOAD_IMAGES_REQUEST,\r\n      data: imageFormData,\r\n    });\r\n  }, []);\r\n\r\n  const onRemoveImage = useCallback(\r\n    (index) => () => {\r\n      dispatch({\r\n        type: REMOVE_IMAGE,\r\n        data: index,\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  return (\r\n    <Form\r\n      style={{ margin: \"10px 0 20px\" }}\r\n      encType=\"mutipart/form-data\"\r\n      onFinish={onSubmit}\r\n    >\r\n      <Input.TextArea\r\n        value={text}\r\n        onChange={onChangeText}\r\n        maxLength={140}\r\n        placeholder=\"어떤 신기한 일이 있었나요?\"\r\n      />\r\n      <div>\r\n        <input\r\n          type=\"file\"\r\n          name=\"image\"\r\n          multiple\r\n          hidden\r\n          ref={imageInput}\r\n          onChange={onChangeImages}\r\n        />\r\n        <Button onClick={onClickImageUpload}>이미지 업로드</Button>\r\n        <Button type=\"primary\" style={{ float: \"right\" }} htmlType=\"submit\">\r\n          짹짹\r\n        </Button>\r\n      </div>\r\n      <div>\r\n        {imagePaths.map((v, i) => (\r\n          <div key={v} style={{ display: \"inline-block\" }}>\r\n            <img\r\n              src={v.replace(/\\/thumb\\//, \"/original/\")}\r\n              style={{ width: \"200px\" }}\r\n              alt={v}\r\n            />\r\n            <div>\r\n              <Button onClick={onRemoveImage(i)}>제거</Button>\r\n            </div>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </Form>\r\n  );\r\n};\r\n\r\nexport default PostForm;\r\n","import React, { useEffect } from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport Head from \"next/head\";\r\nimport { useInView } from \"react-intersection-observer\";\r\nimport { END } from \"redux-saga\";\r\nimport axios from \"axios\";\r\n\r\nimport AppLayout from \"../components/AppLayout\";\r\nimport PostForm from \"../components/PostForm\";\r\nimport PostCard from \"../components/PostCard\";\r\n// export할 때 default를 붙인 경우 중괄호 없이 import 가능\r\n// default 없이 export한 경우 중괄호 안에 담아 import 해줘야 함\r\nimport { LOAD_POSTS_REQUEST } from \"../reducers/post\";\r\nimport { LOAD_MY_INFO_REQUEST } from \"../reducers/user\";\r\nimport wrapper from \"../store/configureStore\";\r\n\r\nconst Home = () => {\r\n  const dispatch = useDispatch();\r\n  const { me } = useSelector((state) => state.user);\r\n  const { mainPosts, hasMorePosts, loadPostsLoading, retweetError } =\r\n    useSelector((state) => state.post);\r\n\r\n  useEffect(() => {\r\n    if (retweetError) {\r\n      alert(retweetError);\r\n    }\r\n  }, [retweetError]);\r\n\r\n  // useEffect(() => {\r\n  //   function onScroll() {\r\n  //     // 페이지 최상단에서 현재 보이는 최상단 까지의 길이(얼마나 내렸는지) - window.scrollY\r\n  //     // 화면 보이는 길이 - document.documentElement.clientHeight\r\n  //     // 총 길이 - document.documentElement.scrollHeight\r\n  //     // 자연스럽게 로딩하는 모습 보여주기 위해 300픽셀 위에서 dispatch하도록\r\n  //     if (\r\n  //       window.scrollY + document.documentElement.clientHeight >\r\n  //       document.documentElement.scrollHeight - 300\r\n  //     ) {\r\n  //       if (hasMorePosts && !loadPostsLoading) {\r\n  //         dispatch({\r\n  //           type: LOAD_POSTS_REQUEST,\r\n  //         });\r\n  //       }\r\n  //     }\r\n  //   }\r\n  //   // useEffect에서 addEventListener할 때는 항상 return해줘야 함 -> scroll 했던 거 해제하기\r\n  //   // 안그러면 계속 메모리에 쌓여있음\r\n  //   window.addEventListener(\"scroll\", onScroll);\r\n  //   return () => {\r\n  //     window.removeEventListener(\"scroll\", onScroll);\r\n  //   };\r\n  // }, [hasMorePosts]);\r\n\r\n  // ref -> 감지할 요소에 연결할 ref\r\n  // inView -> 연결한 ref 요소가 뷰포트 내에 있는지 여부를 나타내는 boolean 값\r\n  // entry ->  Intersection Observer API의 IntersectionObserverEntry 객체\r\n  // -> 이 객체를 사용하여 요소의 위치, 크기 등의 정보를 얻을 수 있음\r\n  const [ref, inView, entry] = useInView();\r\n  useEffect(() => {\r\n    // 로딩중 때문에 속도 느린듯...\r\n    if (inView && hasMorePosts && !loadPostsLoading) {\r\n      const lastId = mainPosts[mainPosts.length - 1]?.id;\r\n      dispatch({\r\n        type: LOAD_POSTS_REQUEST,\r\n        lastId,\r\n      });\r\n    }\r\n  }, [inView, hasMorePosts, loadPostsLoading, mainPosts]);\r\n\r\n  return (\r\n    <>\r\n      <Head>\r\n        <meta charSet=\"utf-8\" />\r\n        <title>NodeBird</title>\r\n        {/* public 폴더에 favicon.ico 파일을 두면, Next.js는 자동으로 해당 파일을 로드하여 브라우저의 탭에 표시함 안뜨면 ctrl+shift+r해서 강력 새로고침하면 됨*/}\r\n        {/* <link rel=\"icon\" href=\"/favicon.ico\" /> */}\r\n      </Head>\r\n      <AppLayout>\r\n        {me && <PostForm />}\r\n        {mainPosts.map((post) => (\r\n          <PostCard key={post.id} post={post} />\r\n        ))}\r\n        {/* 내용의 요소가 없을 때 height를 안주면 감지를 못함 그래서 height를 줘야 감지해서 inView값이 true가 됨 */}\r\n        <div\r\n          ref={hasMorePosts && !loadPostsLoading ? ref : undefined}\r\n          style={{ height: 40 }}\r\n        />\r\n      </AppLayout>\r\n    </>\r\n  );\r\n};\r\n\r\n// getServerSideProps는 브라우저에서 실행X, 프론트서버에서 실행O\r\n// 브라우저 -> 백엔드로 데이터 보낼 때 알아서 쿠키 담아서 보내줌\r\n// 프론트 -> SSR은 주체는 프론트서버기 때문에 백엔드로 데이터 보낼 때 쿠키 담아서 보내줘야 함\r\n// 이부분이 Home보다 먼저 실행됨\r\n// context안에 store가 들어있음\r\n// 실행된 결과를 HYDRATE로 보내줌\r\n// 접속한 상황에 따라 화면이 바뀌어 할 때(웬만하면 getServerSideProps를 사용)\r\nexport const getServerSideProps = wrapper.getServerSideProps(\r\n  async (context) => {\r\n    // 서버쪽에서 실행되면 context.req라는게 존재함\r\n    // 이렇게 해줘야 서버쪽으로 쿠기가 전달됨\r\n    const cookie = context.req ? context.req.headers.cookie : \"\";\r\n    // 서버가 1개이기 때문에 쿠키가 공유되는 문제를 막아야 함\r\n    // 그래서 요청이 들어오면 기존에 있던 유저의 쿠기를 지우고 새로운 유저의 쿠키를 담아주기\r\n    axios.defaults.headers.Cookie = \"\";\r\n    if (cookie) {\r\n      axios.defaults.headers.Cookie = cookie;\r\n    }\r\n    context.store.dispatch({\r\n      type: LOAD_MY_INFO_REQUEST,\r\n    });\r\n    context.store.dispatch({\r\n      type: LOAD_POSTS_REQUEST,\r\n    });\r\n    // SUCCESS까지 기다려주는 장치\r\n    context.store.dispatch(END);\r\n    await context.store.sagaTask.toPromise();\r\n  }\r\n);\r\n\r\nexport default Home;\r\n","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return require(\"private-next-pages/index.js\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  ","import * as React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst observerMap = new Map();\nconst RootIds = new WeakMap();\nlet rootId = 0;\nlet unsupportedValue = undefined;\n/**\r\n * What should be the default behavior if the IntersectionObserver is unsupported?\r\n * Ideally the polyfill has been loaded, you can have the following happen:\r\n * - `undefined`: Throw an error\r\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\r\n * **/\n\nfunction defaultFallbackInView(inView) {\n  unsupportedValue = inView;\n}\n/**\r\n * Generate a unique ID for the root element\r\n * @param root\r\n */\n\nfunction getRootId(root) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n/**\r\n * Convert the options to a string Id, based on the values.\r\n * Ensures we can reuse the same observer when observing elements with the same options.\r\n * @param options\r\n */\n\n\nfunction optionsToId(options) {\n  return Object.keys(options).sort().filter(key => options[key] !== undefined).map(key => {\n    return `${key}_${key === 'root' ? getRootId(options.root) : options[key]}`;\n  }).toString();\n}\n\nfunction createObserver(options) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = observerMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map();\n    let thresholds;\n    const observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        var _elements$get;\n\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView = entry.isIntersecting && thresholds.some(threshold => entry.intersectionRatio >= threshold); // @ts-ignore support IntersectionObserver v2\n\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(callback => {\n          callback(inView, entry);\n        });\n      });\n    }, options); // Ensure we have a valid thresholds array. If not, use the threshold from the options\n\n    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);\n    instance = {\n      id,\n      observer,\n      elements\n    };\n    observerMap.set(id, instance);\n  }\n\n  return instance;\n}\n/**\r\n * @param element - DOM Element to observe\r\n * @param callback - Callback function to trigger when intersection status changes\r\n * @param options - Intersection Observer options\r\n * @param fallbackInView - Fallback inView value.\r\n * @return Function - Cleanup function that should be triggered to unregister the observer\r\n */\n\n\nfunction observe(element, callback, options = {}, fallbackInView = unsupportedValue) {\n  if (typeof window.IntersectionObserver === 'undefined' && fallbackInView !== undefined) {\n    const bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio: typeof options.threshold === 'number' ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds\n    });\n    return () => {// Nothing to cleanup\n    };\n  } // An observer with the same options can be reused, so lets use this fact\n\n\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options); // Register the callback listener for this element\n\n  let callbacks = elements.get(element) || [];\n\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      observerMap.delete(id);\n    }\n  };\n}\n\nconst _excluded = [\"children\", \"as\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\", \"skip\", \"trackVisibility\", \"delay\", \"initialInView\", \"fallbackInView\"];\n\nfunction isPlainChildren(props) {\n  return typeof props.children !== 'function';\n}\n/**\r\n ## Render props\r\n\n To use the `<InView>` component, you pass it a function. It will be called\r\n whenever the state changes, with the new value of `inView`. In addition to the\r\n `inView` prop, children also receive a `ref` that should be set on the\r\n containing DOM element. This is the element that the IntersectionObserver will\r\n monitor.\r\n\n If you need it, you can also access the\r\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\r\n on `entry`, giving you access to all the details about the current intersection\r\n state.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView>\r\n {({ inView, ref, entry }) => (\r\n      <div ref={ref}>\r\n        <h2>{`Header inside viewport ${inView}.`}</h2>\r\n      </div>\r\n    )}\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n\n ## Plain children\r\n\n You can pass any element to the `<InView />`, and it will handle creating the\r\n wrapping DOM element. Add a handler to the `onChange` method, and control the\r\n state in your own component. Any extra props you add to `<InView>` will be\r\n passed to the HTML element, allowing you set the `className`, `style`, etc.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\r\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n */\n\n\nclass InView extends React.Component {\n  constructor(props) {\n    super(props);\n    this.node = null;\n    this._unobserveCb = null;\n\n    this.handleNode = node => {\n      if (this.node) {\n        // Clear the old observer, before we start observing a new element\n        this.unobserve();\n\n        if (!node && !this.props.triggerOnce && !this.props.skip) {\n          // Reset the state if we get a new node, and we aren't ignoring updates\n          this.setState({\n            inView: !!this.props.initialInView,\n            entry: undefined\n          });\n        }\n      }\n\n      this.node = node ? node : null;\n      this.observeNode();\n    };\n\n    this.handleChange = (inView, entry) => {\n      if (inView && this.props.triggerOnce) {\n        // If `triggerOnce` is true, we should stop observing the element.\n        this.unobserve();\n      }\n\n      if (!isPlainChildren(this.props)) {\n        // Store the current State, so we can pass it to the children in the next render update\n        // There's no reason to update the state for plain children, since it's not used in the rendering.\n        this.setState({\n          inView,\n          entry\n        });\n      }\n\n      if (this.props.onChange) {\n        // If the user is actively listening for onChange, always trigger it\n        this.props.onChange(inView, entry);\n      }\n    };\n\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  }\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const {\n      threshold,\n      root,\n      rootMargin,\n      trackVisibility,\n      delay,\n      fallbackInView\n    } = this.props;\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay\n    }, fallbackInView);\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n\n      this._unobserveCb = null;\n    }\n  }\n\n  render() {\n    if (!isPlainChildren(this.props)) {\n      const {\n        inView,\n        entry\n      } = this.state;\n      return this.props.children({\n        inView,\n        entry,\n        ref: this.handleNode\n      });\n    }\n\n    const _this$props = this.props,\n          {\n      children,\n      as\n    } = _this$props,\n          props = _objectWithoutPropertiesLoose(_this$props, _excluded);\n\n    return React.createElement(as || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  }\n\n}\n\n/**\r\n * React Hooks make it easy to monitor the `inView` state of your components. Call\r\n * the `useInView` hook with the (optional) [options](#options) you need. It will\r\n * return an array containing a `ref`, the `inView` status and the current\r\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\r\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\r\n * report the status.\r\n *\r\n * @example\r\n * ```jsx\r\n * import React from 'react';\r\n * import { useInView } from 'react-intersection-observer';\r\n *\r\n * const Component = () => {\r\n *   const { ref, inView, entry } = useInView({\r\n *       threshold: 0,\r\n *   });\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\r\n *     </div>\r\n *   );\r\n * };\r\n * ```\r\n */\n\nfunction useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n  fallbackInView,\n  onChange\n} = {}) {\n  var _state$entry;\n\n  const [ref, setRef] = React.useState(null);\n  const callback = React.useRef();\n  const [state, setState] = React.useState({\n    inView: !!initialInView,\n    entry: undefined\n  }); // Store the onChange callback in a `ref`, so we can access the latest instance\n  // inside the `useEffect`, but without triggering a rerender.\n\n  callback.current = onChange;\n  React.useEffect(() => {\n    // Ensure we have node ref, and that we shouldn't skip observing\n    if (skip || !ref) return;\n    let unobserve;\n    unobserve = observe(ref, (inView, entry) => {\n      setState({\n        inView,\n        entry\n      });\n      if (callback.current) callback.current(inView, entry);\n\n      if (entry.isIntersecting && triggerOnce && unobserve) {\n        // If it should only trigger once, unobserve the element after it's inView\n        unobserve();\n        unobserve = undefined;\n      }\n    }, {\n      root,\n      rootMargin,\n      threshold,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay\n    }, fallbackInView);\n    return () => {\n      if (unobserve) {\n        unobserve();\n      }\n    };\n  }, // We break the rule here, because we aren't including the actual `threshold` variable\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [// If the threshold is an array, convert it to a string, so it won't change between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  Array.isArray(threshold) ? threshold.toString() : threshold, ref, root, rootMargin, triggerOnce, skip, trackVisibility, fallbackInView, delay]);\n  const entryTarget = (_state$entry = state.entry) == null ? void 0 : _state$entry.target;\n  const previousEntryTarget = React.useRef();\n\n  if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {\n    // If we don't have a node ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n    // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n    previousEntryTarget.current = entryTarget;\n    setState({\n      inView: !!initialInView,\n      entry: undefined\n    });\n  }\n\n  const result = [setRef, state.inView, state.entry]; // Support object destructuring, by adding the specific values.\n\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n  return result;\n}\n\nexport { InView, defaultFallbackInView, observe, useInView };\n//# sourceMappingURL=react-intersection-observer.modern.mjs.map\n"],"names":["components_PostForm","_useSelector","useSelector","state","post","imagePaths","addPostDone","dispatch","useDispatch","imageInput","useRef","_useInput","useInput","_useInput2","slicedToArray","Z","text","onChangeText","setText","useEffect","onSubmit","useCallback","trim","alert","formData","FormData","forEach","path","append","type","ADD_POST_REQUEST","data","onClickImageUpload","current","click","onChangeImages","e","console","log","target","files","imageFormData","call","file","UPLOAD_IMAGES_REQUEST","onRemoveImage","index","REMOVE_IMAGE","jsx_runtime","jsxs","es_form","style","margin","encType","onFinish","children","jsx","input","TextArea","value","onChange","maxLength","placeholder","name","multiple","hidden","ref","es_button","onClick","htmlType","map","v","i","display","src","replace","width","alt","pages","me","user","_useSelector2","mainPosts","hasMorePosts","loadPostsLoading","retweetError","_useInView","useInView","_useInView2","inView","_mainPosts","lastId","length","id","LOAD_POSTS_REQUEST","Fragment","head_default","charSet","AppLayout","PostCard","undefined","height","window","__NEXT_P","push","__webpack_require__","unsupportedValue","observerMap","Map","RootIds","WeakMap","rootId","threshold","delay","trackVisibility","rootMargin","root","triggerOnce","skip","initialInView","fallbackInView","_state$entry","setRef","react__WEBPACK_IMPORTED_MODULE_0__","useState","callback","setState","entry","unobserve","observe","element","options","IntersectionObserver","bounds","getBoundingClientRect","isIntersecting","intersectionRatio","time","boundingClientRect","intersectionRect","rootBounds","observer","elements","createObserver","Object","keys","sort","filter","key","has","set","toString","get","instance","thresholds","entries","_elements$get","some","isVisible","Array","isArray","callbacks","splice","indexOf","delete","size","disconnect","entryTarget","previousEntryTarget","result"],"sourceRoot":""}